"""
 Списки и матрицы: minimum minimorum + штучки для линейной алгебры
 
 Сегодня в программе:
 - создание списков
 - наполнение, конкатенация
 
 Из традиционного пока не будет:
 - сортировок
 - поиска в упорядоченном массиве
 - обработки списков в стиле функционального программирования [ну, чуть-чуть]
 - 
"""

a = [2, 12, 85, 0, 6]

# заполнение по одному элементу
# append добавляет в конец
a.append("это")
a.append("твой")

# трижды добавляем один и тот же элемент в конец
for i in range(3):
	a.append("номер")

print(a)

quit()

# заполнение пачками
# то есть происходит "склеивание" двух списков, дописывание того, что в скобках, к первому
# extend и + для списков -- примерно то же самое 
a = a + ["!"]
a.extend([1,2,3])
a = a + a

#
# ВНИМАНИЕ!!!
# ----------------
# если мы сделаем
# [1,2,3].append(4)
# получим [1,2,3,4]
# 
# если мы сделаем
# [1,2,3].append([4])
# получим [1,2,3,[4]]
# 
# extend -- "наращивает" таким же списком
# append -- добавляет в конец ЭЛЕМЕНТ
#

print(a)

quit()

a = [2, 13, 40, 25]

# доступ до элементов
print(a[0])
print(a[5])

quit()

a = [2, 13, 40, 25]

# длина = len
print(a)
print(len(a))

quit()

# Самостоятельная работа 
# Задание: пользуясь for, len, range и доступом до элементов  
# по индексу, распечатать список -- каждый элемент с новой строчки
# Решение ========================================================

# перебираем числа от 0 до длины списка
for i in range(len(a)):
	# распечатываем элемент на соотвествующей позиции
	print(a[i])

# Самостоятельная работа 
# Задание: пользуясь for, len, range и доступом до элементов  
# по индексу, распечатать элементы списка на ЧЁТНЫХ ПОЗИЦИЯХ -- каждый элемент с новой строчки
# Решение == несколько вариантов ======================================================

# перебираем числа от 0 до длины списка
for i in range(len(a)):
	# если остаток позиции при делении на 2 равен 0, то есть если число чётное
	if i % 2 == 0:
		# распечатываем
		print(a[i])

# или

# перебираем числа от 0 до длины списка с шагом 2
for i in range(0, len(a), 2):
	print(a[i])

quit()

# Распечатка списка с использованием in
# ВНИМАНИЕ! НОВОЕ!
# здесь на каждом шаге в переменную element подставляется очередной элемент массива a
for element in a:
	print(element, end=" ")
print()

# Самостоятельная работа 
# Задание: пользуясь for и if  
# по индексу, распечатать только ЧЁТНЫЕ элементы списка -- каждый элемент с новой строчки
# Решение ========================================================

# перебор по элементам
for e in a:
	# если элемент делится на два, печатаем
	if e % 2 == 0:
		print(e)

# или

# перебор по позициям от 0 до длины списка
for i in range(len(a)):
	# если элемент делится на два, печатаем
	if a[i] % 2 == 0:
		print(a[i])


quit()

# поиск строгого минимума
a = [1, 3, 1, 2, 4, 5, 6, 777, 55, 777, 777, 777]

maybe_min = a[0]

for element in a:
	if element < maybe_min:
		maybe_min = element

print("Min:", maybe_min)

quit()

# Самостоятельная работа 
# Найти строгий минимум и его позицию в списке
# Решение ========================================================

# поиск строгого минимума & position
a = [1, 3, 1, 2, 4, 5, 6, 777, 55, 777, 777, 777]

maybe_min = a[0]
min_pos = 0

for index in range(len(a)):
	if a[index] < maybe_min:
		maybe_min = a[index]
		min_pos = index

print("Min:", maybe_min, "Pos:", min_pos)

quit()

# Самостоятельная работа 
# Найти минимум и "вице-минимум" [или равный ему ещё один минимум] и их позиции в списке
# Решение == два варианта ======================================================
a = [1, 3, 1, 2, 4, 5, 6, 777, 55, 777, 777, 777]

######### За два прохода (не самое эффективное решение)
# делаем просто поиск позиции минимума
min = a[0]
min_pos  = 0

for i in range(len(a)):
	if a[i] < min:
		min = a[i]
		min_pos = i

# делаем поиск минимума НА ДРУГОЙ ПОЗИЦИИ
vice_min = a[0]
vice_min_posn_pos  = 0

for i in range(len(a)):
	# если текущий элемент МЕНЬШЕ текущего минимума и позиция не равна позиции уже найденного строгого минимума
	if a[i] <= vice_min and min_pos != i:
		vice_min = a[i]
		vice_min_pos = i


######### За один проход (решение поэффективнее, но немного страшнее)
# смотрим на два первых элемента и с умом задаём начальные значения
# они не должны указывать на один и тот же элемент
# иначе в случае [-1, 1,2,4,56,99] в качестве ответа получим -1 на нулевой позиции
# как дkя минимума так и для вице-минимума, а это не то, что мы хотим
a = [1, 3, 2, 4, 5, 6, 777, 55, 777, 777, 777]

if a[0] >= a[1]:
	min = a[1]
	min_pos = 1
	vice_min = 0
	vice_min_pos = a[0]
else:
	min = a[0]
	min_pos = 0
	vice_min = a[1]
	vice_min_pos = 1

print("Initial min and vice_min", min, vice_min)

for i in range(2, len(a)):
	# если текущий элемент строго меньше
	if a[i] < min:
		# параметры вице-минимума обновляем значениями для текущего минимума
		vice_min = min
		vice_min_pos = min_pos
		# параметры минимума обновляем значениями для текущего элемента
		min = a[i]
		min_pos = i
	# если значение между минимумом и вице-минимумом
	elif a[i] < vice_min:
		# то это новый вице-минимум
		vice_min = a[i]
		vice_min_pos = i

print("Min", min,"on position", min_pos)
print("Vice-Min", vice_min,"on position", vice_min_pos)
		


quit()

# Сохранения всех подходящих под условие элементов
# Допустим, нас интересуют делящиеся на три

# задаём пустой список
accumulator = []

# для каждого элемента списка
for element in a:
	if element % 3 == 0:
		accumulator.append(element)

print(accumulator)

quit()

# Самостоятельная работа 
# Вывести список всех максимумов и список их позиций в исходном массиве
# Решение =============================================================

a = [1, 3, 1, 2, 4, 5, 6, 777, 55, 777, 777, 777]

# значение первого элемента
maybe_max = a[0]
# пустой список, в который будем складывать позиции "кандидатов на максимумы"
max_val_positions = []

# для всех целых от 0 до размера массива
for index in range(len(a)):
	# если текущее значение больше предыдущего максимума
	if a[index] > maybe_max:
		# обновляем значение максимума
		maybe_max = a[index]
		# в списке у нас были накоплены позиции меньших элементов
		# больше они нам не нужны, поэтому мы просто его задаём заново,
		# сразу положив позицию текущего элемента
		max_val_positions = [index]
	# если значение текущего элемента списка совпадает с текущим максимумом, просто добавляем его позицию в список позиций максимумов
	elif a[index] == maybe_max:
		max_val_positions.append(index)

print("Max:", maybe_max, "Pos:", max_val_positions)


quit()

# как поменять элементы местами
a = [1,2,3,4,5]

# ну, не так точно
a[3] = a[2]
a[2] = a[3]
print(a)

quit()

a = [1,2,3,4,5]

# а вот так 
k = a[3]
a[3] = a[2]
a[2] = k

print(a)

quit()

a = [1,2,33,4,5,6,7]

# Поменяем местами все элементы на нечётных позициях с соседними на меньших чётных:0-1,2-3,...
# [падение запланировано]
# РЕШЕНИЕ ==================================
# Здесь классическая ошибка на единицу в индексах
# Если у нас нечётное число элементов, то последний и не надо менять, поэтому можно перебирать до len(a) - 1
for i in range(len(a) - 1):#range(len(a)):
	if i % 2 == 0:
		temp = a[i]
		a[i] = a[i + 1]
		a[i + 1] = temp

print(a)

quit()

# *Самостоятельная работа
# как это можно переписать без if и остатка от деления?
# ПОДСКАЗКА ===========================================
# посмотрите на разные варианты работы с range

quit()

# Самостоятельная работа
# 'зеркальный' переворот списка: [11,2,3,444,5] -> [5,444,3,2,11]
# ПОДСКАЗКА ===========================================
# здесь надо как-то менять местами элементы и ходить по индексам

quit()

# Самостоятельная работа
# циклический сдвиг списка: [11,2,3,444,5], сдвиг на n вправо -> [3,444,5,11,2]
# ПОДСКАЗКА ===========================================
# несколько вариантов решений: 
# 1) оторвать-склеить списки
# 2) цикл в цикле: запоминаем последний элемент, все остальные в цикле по позициям сдвигаем вправо, проставляем значение бывшего "последнего" на первое место; и так n раз, а если n > len(a_list), то можно и меньше. Кстати, сколько?
# 3) хитрый способ: зеркально отразить список, зеркально отразить первые n элементов, зеркально отразить остальные элементы. Готово!

quit() 

# Вычисление нормы
# |[a_1,a_2,a_3,...]| = sqrt(sum_i (a_i ^ 2))
# квадратный корень из суммы квадратов координат

import math

# "вектор", норму которого будем вычислять
a = [.4, .2222, 444.4, 23.0]

# в эту переменную запишем значение нормы
norm_res = 0

# для каждого значения в a
for x in a:
	# добавляем к norm_res квадрат координаты
	norm_res = norm_res + x ** 2

norm_res = math.sqrt(norm_res)

print(norm)

quit()

# Самостоятельная работа
# "нормализовать" значения в списке вещественных чисел так, чтобы сумма была равна 1
# ПОДСКАЗКА ===========================================
# Одним циклом посчитать сумму, другим циклом разделить на сумму

quit()

# Самостоятельная работа
# "сложение двух списков": даны 2 списка, возможно, разной длины
# на выходе должен быть список длиной, равной длине самого короткого, и каждый элемент должен равняться сумме двух соответствующих
# ПОДСКАЗКА ===========================================
# вычислить наименьшую длину, и, используя её в range, создавать новый список или обновлять один из старых

quit()

# Генерация списка одинаковых элементов
# Размножаем "42" -- будет список из 12 элементов
a = [42] * 12

quit()

# ------------------------------------- MATRICES ---------------------------------------------------
# Для массивов очень много других классических и важных задач, но давайте всё же перейдём к матрицам
# Матрица для нас сейчас -- это список списков одинаковой длины

# матрица -- как список четырёх одинаковых списков a
b = [a, a, a, a] 
print(b)

quit()

# доступ до элемента
# это первый элемент -- то есть певрый список -- то есть 'a'
print(b[0])

quit()

# доступ до значения на строке 0 в столбце 2
# берём нулевой элемент -- то есть список-строку как элемент на нулевой позиции
# а в нём берём второй элемент
print(b[0][2])

quit()

# Распечатка матрицы
# для каждого инжеста строки
for row_if in range(len(b)):
	# для каждого индекса столбца
	for column_id in range(len(b[0])):
		# печатаем значение элемента на пересечении этих колоки и столбца и дописываем "Tab"
		print(b[row_id][column_id], end="\t")
	# делаем перевод строки
	print()

quit()

# Построение нулевой матрицы
rows = 10
columns = 15

# пустой список
m = []

# для номеров строк от 0 до rows
for i in range(rows):
	# создаём строку как пустой список
	row = []
	
	# для каждого индекса для столбца 
	for j in range(columns):
		# добавляем элемент в строку
		row.append(0)
		
	# прикрепляем строку к матрице
	m.append(row)
	# печатаем текущее состояния строящейся матрицы
	print(m)

# Может, можно как-то покороче?
		
quit()

# заполнение матрицы по строчкам подряд идущими целыми числами

counter = 0

# для каждого номера строки (их число -- размер списка списков b)
for row_if in range(len(b)):
	# для каждого номера колонки (их число -- размер любого списка, из которых составлен b, например, нулевого)
	for column_id in range(len(b[0])):
		# задаём значение элемента в выбранных строке и колонке
		b[row_id][column_id] = counter
		# увеличиваем счётчик на единицу
		counter = counter + 1

quit()

# Самостоятельная работа
# Заполнение матрицы подряд идущими цифрами по столбцам
# Аналогично

rows = 10 # число строк
columns = 15 # число колонок

quit()

# Самостоятельная работа
# - конкатенация матриц
#   "поставить" одну на другую две матрицы одинакового размера

# Самостоятельная работа
# - создать в цикле единичную матрицу, квадратную, конечно, размер -- в переменной

# Самостоятельная работа
# - создать треугольную матрицу, заполнив ненулевые элементы подряд идущими числами,
#   4 варианта: верхний правый треугольник, нижний правый, ...

# Самостоятельная работа
# - транспонирование "прямоугольных" матриц (надо, чтобы можно было модифицировать параметры rows и columns)

# Самостоятельная работа
# - нормализация строк, столбцов
# - найти 2-3 нормы и применить их

# Самостоятельная работа
# - сложение матриц одинакового размера

# Самостоятельная работа
# - поэлементное умножение матриц одинакового размера

# Самостоятельная работа
# Умножение матриц размером NxK и KxM:
# 1] сгенерировать матрицы соответствующего размера
# 2] распечатать обе матрицы и их произведение
# 3] продемонстрировать корректность: например, показать, что умножение квадратной матрицы на единичную выдаёт её же как результат


